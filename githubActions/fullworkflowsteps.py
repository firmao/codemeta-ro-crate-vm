import requests
import json
import base64

class VREOrchestrator:
    def __init__(self, repo_url):
        self.repo_url = repo_url.strip("/")
        self.owner_repo = "/".join(self.repo_url.split("/")[-2:])
        self.api_url = f"https://api.github.com/repos/{self.owner_repo}/contents"
        self.files = {}
        self.codemeta = None
        self.workflow_yaml = None

    def step_1_analyze_repository(self):
        """Fetches repo content and checks for existing metadata/CI files."""
        print(f"--- Step 1: Analyzing {self.owner_repo} ---")
        response = requests.get(self.api_url)
        
        if response.status_code != 200:
            return "Error: Repository not found or inaccessible."

        repo_contents = [f['name'] for f in response.json()]
        
        # Check for CodeMeta
        if 'codemeta.json' in repo_contents:
            print("[✓] Found existing CodeMeta file. Enriching...")
            self.codemeta = self._fetch_file_content("codemeta.json")
        else:
            print("[!] CodeMeta missing. Generating using generator...")
            self.codemeta = self._generate_codemeta_stub()

        # Check for GitHub Action YAML
        workflow_path = ".github/workflows"
        self.workflow_yaml = self._find_yaml_in_workflows(workflow_path)
        
        if self.workflow_yaml:
            print(f"[✓] Found YAML workflow: {self.workflow_yaml['name']}")
            self.codemeta["buildInstructions"] = f"{self.repo_url}/blob/main/{self.workflow_yaml['path']}"
        else:
            print("[!] No CI/CD YAML found. Invoking GenAI Generator...")
            self.workflow_yaml = self._generate_ai_yaml()
            self.codemeta["buildInstructions"] = "Generated by VRE-AI"

    def step_2_user_inspection(self):
        """Simulates the UI step where a user edits the files."""
        print("\n--- Step 2: User Inspection & Edit ---")
        # In a real web app, this would be an API endpoint returning JSON to a frontend editor
        print(f"Current CodeMeta Name: {self.codemeta['name']}")
        print(f"Build Script Length: {len(self.workflow_yaml['content'])} chars")
        return True

    def step_3_test_deployment(self, server_url, credentials):
        """Simulates testing on a SANE/NDE-style test server."""
        print(f"\n--- Step 3: Testing Deployment on {server_url} ---")
        # Logic to send the YAML and Code to a DAB or test runner
        print(f"Authenticating with {credentials.get('username')}...")
        print("Running build environment setup...")
        return "Success"

    def step_4_package_results(self):
        """Prepares files for download."""
        print("\n--- Step 4: Packaging Files ---")
        return {
            "codemeta.json": json.dumps(self.codemeta, indent=2),
            "workflow.yml": self.workflow_yaml['content']
        }

    def step_5_publish_to_kg(self):
        """Publishes to Knowledge Graph including YAML-LD conversion."""
        print("\n--- Step 5: Publishing to Knowledge Graph ---")
        # Logic for YAML-LD conversion (conceptual)
        yaml_ld = {
            "@context": "https://json-ld.github.io/yaml-ld/context.jsonld",
            "original_yaml": self.workflow_yaml['content']
        }
        print("Published CodeMeta and YAML-LD to Knowledge Graph.")

    # --- Helper Utilities ---

    def _fetch_file_content(self, path):
        resp = requests.get(f"{self.api_url}/{path}")
        if resp.status_code == 200:
            content = base64.b64decode(resp.json()['content']).decode('utf-8')
            return json.loads(content) if path.endswith('.json') else content
        return None

    def _find_yaml_in_workflows(self, path):
        resp = requests.get(f"{self.api_url}/{path}")
        if resp.status_code == 200:
            files = resp.json()
            for f in files:
                if f['name'].endswith(('.yml', '.yaml')):
                    return {'name': f['name'], 'path': f['path'], 'content': self._fetch_file_content(f['path'])}
        return None

    def _generate_codemeta_stub(self):
        return {
            "@context": "https://doi.org/10.5063/schema/codemeta-2.0",
            "@type": "SoftwareSourceCode",
            "name": self.owner_repo.split('/')[-1],
            "developmentStatus": "active"
        }

    def _generate_ai_yaml(self):
        # Placeholder for GenAI integration
        content = """name: VRE Auto-Build
on: [push]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Setup Environment
        run: echo "Setting up toolchain..."
"""
        return {'name': 'auto-generated.yml', 'path': '.github/workflows/auto.yml', 'content': content}

# --- Execution Flow ---
if __name__ == "__main__":
    # Example Usage
    repo = "https://github.com/firmao/codemeta-ro-crate-vm/"
    vre = VREOrchestrator(repo)
    
    vre.step_1_analyze_repository()
    vre.step_2_user_inspection()
    
    # Simulate Step 3 Popup data
    user_creds = {"username": "admin", "token": "secret_abc"}
    if vre.step_3_test_deployment("https://test-server.vre.org", user_creds) == "Success":
        files = vre.step_4_package_results()
        vre.step_5_publish_to_kg()